# 多集群通信设计

## 概述

多集群通信是为了让多个异构的，分布在不同网络的集群可以相互访问彼此的节点和服务(目前仅支持集群的云端节点相互通信)

多个通信的集群中必须且只能有一个根集群，其他集群是根集群的子集群, 每个子集群在根集群注册自己需要外部通信的端点信息（目前仅限于Connector)。

集群间不能直接通信, 用户需要在主集群通过社区来组织需要通信的集群，在同一个社区的集群才能相互访问。

各个集群间的节点，Pod，服务的地址不能重复。

## 集群分类

### 按系统分类

* 常规Kubernetes集群
* 边缘计算集群(KubeEdge/OpenYurt/SuperEdge).

### 按拓扑结构分类

* 所有节点都在一个区域，网络也在一个局域网，通常是企业内部或云上的一个Kubernetes集群，运行各种服务，也可能是某种设施的小型集群。
* 管理节点在云端，边缘节点分布在多个位置，使用不同的网络. 

### 按角色分类

通信的集群可以有多个，但角色分为两类：根集群和子集群，根集群必须且只能有一个

根集群的功能如下：

* 证书派发。所有集群的根证书存储在根机群，子集群可以从根集群为Connector和边缘节点申请证书。
* 集中存储每个集群暴露的端点信息，目前仅限于Connector
* 社区管理，需要通信的集群必须在同一社区
* 向其他集群下发需要通信的集群的端点信息

子集群的功能如下：
* 向根集群申请本集群的端点证书
* 向根集群提供自身对外暴露的端点信息
* 通过根集群获取其他集群的端点信息，并跟其他集群建立通信

## 自定义资源

为了管理多集群间的通信，需要添加或修改一些CRD。

Community原先用于管理一个集群内部边缘节点间的通信，为了支持多集群通信，需要标明成员类型，支持的成员类型为: Connector和EdgeNode，目前一个社区内的成员类型必须统一。目前跨集群的边缘节点暂不支持，成员类型为EdgeNode的社区只能支持集群内部通信。

Community的Members列表原先是集群内的边缘节点列表，现在为了支持跨集群通信，成员的数据结构要调整，每个成员必须包含如下字段:

 * name. 成员名称
 * cluster. 成员所属集群。可以为空，会被视为本集群节点。

目前社区的成员类型必须统一，也不支持跨集群的边缘节点间通信。



Cluster:

 * name. 集群名称，每个子集群访问根集群时声明自己的身份。

 * token. 用于子集群跟根集群之间的通信。

 * endpoints. 该集群内部所有需要跟其他集群通信的端点信息，其中Connector是必须上传的。

   	* Name. 必须唯一，建议需要通信的集群在配置cluster domain时也保持唯一。
   * PublicAddresses. 集群用于对外通信的公网地址，该地址必须可以被其他集群和本集群的边缘节点(如果有)访问
   * Subnets. 主要是集群的PodCIDRs数据，但也含有提供集群的ServiceCIDR。
   * NodeCIDRs. 集群内部云端节点的所有节点的IP地址
   * Type. 表明端点类型： Connector和EdgeNode

   

## 名称管理

各个集群都有Connector，节点名称也可能重复，但使用社区时，需要保证成员名称唯一，为了达到这个目标，在每个集群上报本集群的端点信息时需要将名称修改一下，加上集群前缀，比如 cluster1的Connector名称要改为: cluster1.connector。